#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <EEPROM.h>
#include <time.h>
#include <WiFiClientSecure.h>

// WiFi credentials
const char* ssid = "xxxxxx";
const char* password = "xxxxx";

// Google Script URL
const char* scriptURL = "https://script.google.com/macros/s/xxxxxxxxxxxxx/exec";

// Pins for presses
const int switchPins[5] = {5, 4, 0, 2, 14}; // D1, D2, D3, D4, D5

// Timing
const unsigned long debounceDelay = 30000;
const unsigned long sendInterval = 60000;
const int timezone = 19800; // IST +5:30

// Structure for each press
struct PressData {
  unsigned long startMillis;
  unsigned long startEpoch;
  unsigned long lastDebounceTime;
  bool lastSwitchState;
  bool currentSwitchState;
  bool isPressed;
  bool startDataSent;
  unsigned long lastUpdateTime;
  char startDate[12];
  char startTimeStr[10];
  int eepromAddr;
};

PressData presses[5];
bool wifiConnected = false;

// ---------- Function Declarations ----------
void connectWiFi();
void testConnection();
void handlePress(int index);
void sendToSheet(int index, unsigned long duration, bool isComplete, bool isStart);
void saveToEEPROM(int index);
void clearEEPROM(int index);
void recoverFromPowerLoss();
void getDateTime(char* dateStr, char* timeStr);

// ---------- SETUP ----------
void setup() {
  Serial.begin(115200);
  delay(1000);
  Serial.println("\n\n=== Century Plywood Press Monitor ===");

  EEPROM.begin(512);

  for (int i = 0; i < 5; i++) {
    pinMode(switchPins[i], INPUT_PULLUP);
    presses[i].eepromAddr = i * 60;
    presses[i].lastSwitchState = HIGH;
    presses[i].currentSwitchState = HIGH;
    presses[i].isPressed = false;
    presses[i].startDataSent = false;
    presses[i].lastDebounceTime = 0;
    presses[i].startMillis = 0;
    presses[i].startEpoch = 0;
    presses[i].lastUpdateTime = 0;
  }

  connectWiFi();

  // Configure time
  Serial.println("Syncing time...");
  configTime(timezone, 0, "pool.ntp.org", "time.nist.gov");
  int timeAttempts = 0;
  while (time(nullptr) < 100000 && timeAttempts < 20) {
    delay(500);
    Serial.print(".");
    timeAttempts++;
  }
  Serial.println("\nTime synced!");

  testConnection();
  recoverFromPowerLoss();

  Serial.println("System Ready!\n");
}

// ---------- LOOP ----------
void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    wifiConnected = false;
    Serial.println("WiFi disconnected! Reconnecting...");
    connectWiFi();
  } else {
    wifiConnected = true;
  }

  for (int i = 0; i < 5; i++) {
    handlePress(i);
  }

  // Periodic updates for ongoing presses
  unsigned long currentMillis = millis();
  for (int i = 0; i < 5; i++) {
    if (presses[i].isPressed && presses[i].startDataSent) {
      if (currentMillis - presses[i].lastUpdateTime >= sendInterval) {
        unsigned long nowEpoch = time(nullptr);
        unsigned long duration = nowEpoch - presses[i].startEpoch;
        if (duration >= 30) {
          Serial.printf("Sending periodic update for Press %d\n", i + 1);
          sendToSheet(i, duration, false, false);
          presses[i].lastUpdateTime = currentMillis;
        }
      }
    }
  }

  delay(50);
}

// ---------- HANDLE PRESS ----------
void handlePress(int index) {
  int reading = digitalRead(switchPins[index]);

  if (reading != presses[index].lastSwitchState) {
    presses[index].lastDebounceTime = millis();
  }

  if ((millis() - presses[index].lastDebounceTime) > debounceDelay) {
    if (reading != presses[index].currentSwitchState) {
      presses[index].currentSwitchState = reading;

      if (presses[index].currentSwitchState == LOW) {
        if (!presses[index].isPressed) {
          presses[index].startMillis = millis();
          presses[index].startEpoch = time(nullptr);
          presses[index].isPressed = true;
          presses[index].startDataSent = false;
          presses[index].lastUpdateTime = millis();
          getDateTime(presses[index].startDate, presses[index].startTimeStr);
          saveToEEPROM(index);

          Serial.println("==============================");
          Serial.printf("‚úì Press %d STARTED\n", index + 1);
          Serial.printf("  Date: %s\n", presses[index].startDate);
          Serial.printf("  Time: %s\n", presses[index].startTimeStr);
          Serial.println("==============================");

          // IMMEDIATELY send start data to sheet
          sendToSheet(index, 0, false, true);
          presses[index].startDataSent = true;
        }
      } else {
        if (presses[index].isPressed) {
          unsigned long nowEpoch = time(nullptr);
          unsigned long duration = nowEpoch - presses[index].startEpoch;

          Serial.println("==============================");
          Serial.printf("‚úì Press %d ENDED\n", index + 1);
          Serial.printf("  Duration: %lu seconds\n", duration);
          Serial.println("==============================");

          sendToSheet(index, duration, true, false);
          presses[index].isPressed = false;
          presses[index].startDataSent = false;
          clearEEPROM(index);
        }
      }
    }
  }

  presses[index].lastSwitchState = reading;
}

// ---------- SEND TO SHEET ----------
void sendToSheet(int index, unsigned long duration, bool isComplete, bool isStart) {
  const int MAX_RETRIES = 3;
  const int RETRY_DELAY = 5000;
  bool success = false;

  for (int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("‚ö†Ô∏è WiFi disconnected! Attempting to reconnect...");
      connectWiFi();
      if (WiFi.status() != WL_CONNECTED) {
        Serial.printf("‚ùå WiFi reconnect failed (attempt %d/%d)\n", attempt, MAX_RETRIES);
        delay(RETRY_DELAY);
        continue;
      }
    }

    WiFiClientSecure client;
    client.setInsecure();

    HTTPClient http;
    String actionType = isStart ? "START" : (isComplete ? "END" : "UPDATE");
    Serial.printf("\nüì§ Sending %s data for Press %d (attempt %d/%d)...\n", 
                  actionType.c_str(), index + 1, attempt, MAX_RETRIES);

    http.begin(client, scriptURL);
    http.addHeader("Content-Type", "application/x-www-form-urlencoded");
    http.setTimeout(30000);

    char endTime[10] = "";
    if (isComplete) {
      char endDate[12];
      getDateTime(endDate, endTime);
    }

    int minutes = duration / 60;
    int seconds = duration % 60;
    char durationStr[20];
    sprintf(durationStr, "%d:%02d", minutes, seconds);

    String postData = "press=" + String(index + 1) +
                     "&date=" + String(presses[index].startDate) +
                     "&startTime=" + String(presses[index].startTimeStr) +
                     "&endTime=" + String(endTime) +
                     "&duration=" + String(durationStr) +
                     "&complete=" + String(isComplete ? "1" : "0") +
                     "&isStart=" + String(isStart ? "1" : "0");

    Serial.println("Data: " + postData);

    int httpCode = http.POST(postData);
    if (httpCode > 0) {
      Serial.printf("‚úì HTTP Code: %d\n", httpCode);
      String payload = http.getString();
      Serial.println("‚úì Response: " + payload);
      if (httpCode == 200 || httpCode == 302) {
        Serial.println("‚úÖ Data sent successfully!\n");
        success = true;
        http.end();
        break;
      }
    } else {
      Serial.printf("‚ùå HTTP Error: %s\n", http.errorToString(httpCode).c_str());
    }

    http.end();
    if (attempt < MAX_RETRIES) {
      Serial.printf("üîÅ Retrying in %d seconds...\n", RETRY_DELAY / 1000);
      delay(RETRY_DELAY);
    }
  }

  if (!success) {
    Serial.println("‚ùå All retry attempts failed. Restarting ESP in 5 seconds...");
    delay(5000);
    ESP.restart();
  }
}

// ---------- GET DATETIME ----------
void getDateTime(char* dateStr, char* timeStr) {
  time_t now = time(nullptr);
  struct tm* timeinfo = localtime(&now);
  if (timeinfo->tm_year < 100) {
    strcpy(dateStr, "01/01/2024");
    strcpy(timeStr, "00:00:00");
    return;
  }
  sprintf(dateStr, "%02d/%02d/%04d", timeinfo->tm_mday, timeinfo->tm_mon + 1, timeinfo->tm_year + 1900);
  sprintf(timeStr, "%02d:%02d:%02d", timeinfo->tm_hour, timeinfo->tm_min, timeinfo->tm_sec);
}

// ---------- EEPROM SAVE / CLEAR ----------
void saveToEEPROM(int index) {
  int addr = presses[index].eepromAddr;
  EEPROM.write(addr, 0xAA);
  EEPROM.put(addr + 1, presses[index].startEpoch);
  for (int i = 0; i < 12; i++) EEPROM.write(addr + 9 + i, presses[index].startDate[i]);
  for (int i = 0; i < 10; i++) EEPROM.write(addr + 21 + i, presses[index].startTimeStr[i]);
  EEPROM.commit();
  Serial.printf("üíæ Saved Press %d to EEPROM\n", index + 1);
}

void clearEEPROM(int index) {
  int addr = presses[index].eepromAddr;
  EEPROM.write(addr, 0x00);
  EEPROM.commit();
  Serial.printf("üíæ Cleared Press %d from EEPROM\n", index + 1);
}

// ---------- RECOVER ----------
void recoverFromPowerLoss() {
  Serial.println("\nüîç Checking for power loss recovery...");
  bool recovered = false;
  for (int i = 0; i < 5; i++) {
    int addr = presses[i].eepromAddr;
    if (EEPROM.read(addr) == 0xAA) {
      unsigned long savedEpoch;
      EEPROM.get(addr + 1, savedEpoch);
      for (int j = 0; j < 12; j++) presses[i].startDate[j] = EEPROM.read(addr + 9 + j);
      for (int j = 0; j < 10; j++) presses[i].startTimeStr[j] = EEPROM.read(addr + 21 + j);
      presses[i].startEpoch = savedEpoch;
      presses[i].isPressed = true;
      presses[i].startDataSent = true; // Already sent before power loss
      presses[i].lastUpdateTime = millis();
      Serial.printf("‚úì Recovered Press %d from power loss\n", i + 1);
      Serial.printf("  Original start: %s %s\n", presses[i].startDate, presses[i].startTimeStr);
      recovered = true;
    }
  }
  if (!recovered) Serial.println("No recovery needed - fresh start");
}

// ---------- WIFI ----------
void connectWiFi() {
  Serial.println("\nüì° Connecting to WiFi...");
  Serial.printf("SSID: %s\n", ssid);
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 40) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println("\n‚úì WiFi Connected!");
    Serial.print("IP Address: "); Serial.println(WiFi.localIP());
    Serial.print("Signal Strength: "); Serial.print(WiFi.RSSI()); Serial.println(" dBm");
  } else {
    wifiConnected = false;
    Serial.println("\n‚ùå WiFi Connection Failed! Restarting in 5 seconds...");
    delay(5000);
    ESP.restart();
  }
}

// ---------- TEST CONNECTION ----------
void testConnection() {
  Serial.println("\nüß™ Testing Google Script connection...");
  WiFiClientSecure client;
  client.setInsecure();
  HTTPClient http;
  http.begin(client, scriptURL);
  http.setTimeout(15000);
  int httpCode = http.GET();
  if (httpCode > 0) {
    Serial.printf("‚úì Connection successful! HTTP Code: %d\n", httpCode);
    String payload = http.getString();
    Serial.println("Response: " + payload);
  } else {
    Serial.printf("‚ùå Connection failed! Error: %s\n", http.errorToString(httpCode).c_str());
    Serial.println("\n‚ö†Ô∏è  IMPORTANT: Check your Google Script URL!");
  }
  http.end();
}
